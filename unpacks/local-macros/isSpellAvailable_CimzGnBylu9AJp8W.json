{
  "name": "isSpellAvailable",
  "type": "script",
  "scope": "global",
  "author": "v0RvORcwGexWLCjc",
  "img": "icons/svg/dice-target.svg",
  "command": "function isSpellAvailable(actor, spell, { readyToCast = true, spellRank = null, spellcastingEntry = null} = {}) {\n    //if the actor isn't a spellcaster, what are we even doing\n    if (!actor?.isSpellcaster) return false;\n\n    let spellName = \"\";\n    let isFocusSpell = false;\n    //if passed a Spell object, use its name and rank, check if focus spell or cantrip\n    if (typeof spell === 'string') {\n        spellName = spell;\n    } else if (['spell', 'focus'].includes(spell?.category?.value)) {\n        spellName = spell.name;\n        spellRank ??= spell.rank;\n        isFocusSpell = spell.isFocusSpell;\n    } else {\n        return ui.notifications.error('isSpellAvailable: spell must be a string or a non-ritual spell object.');\n    }\n    \n    if (spellRank !== null && (spellRank < 1 || spellRank > 11)) {\n\t\treturn ui.notifications.error(`isSpellAvailable: spellRank must be between 1 and 11, provided ${spellRank}`)\n\t}\n\t\n    //limit to focus entries if passed focus spell, ignore ritual entries\n    let entries = actor.spellcasting.contents.filter(e => !e.isRitual && (!isFocusSpell || e.isFocusPool)) ?? [];\n    //if provided an entry name, find just that one\n    // console.warn(entries)\n    if (spellcastingEntry) {\n        selectedEntry = entries.find(e => e.name === spellcastingEntry);\n        if (!selectedEntry) {\n            return ui.notifications.error(`isSpellAvailable: Spellcasting entry '${spellcastingEntry}' does not exist on actor ${actor?.name}`);\n        }\n        entries = [selectedEntry];\n    }\n    for (let entry of entries) {        \n        // we want a spell matching the name, and that matches one of \n        // - is the rank specified\n        // - is a cantrip\n        // - is a signature spell\n        // if there's more than one, take the one with the lowest rank\n        const extantSpell = entry.spells.contents\n                            .filter(sp => \n                                sp.name === spellName\n                                && (sp.isCantrip\n                                || (spellRank && sp.rank === spellRank)\n                                || sp.system?.location?.signature\n                                || !spellRank)) \n                            .reduce((prev,curr) => (prev?.rank < curr?.rank ? prev : curr), null);\n        // if spell isn't found in this entry, it can't be available via it, try the next one\n        // console.warn('extantSpell', extantSpell)\n        if (!extantSpell) continue; \n\n        //if we just want to check if the spell is prepared/known, we can call it here\n        if (!readyToCast) return true;\n        \n        const spellID = extantSpell._id;        \n        const allSlots = Object.values(entry.system.slots);\n        // cantrips can always be cast unless they're not prepared in a prepared entry\n        if (extantSpell.isCantrip) {\n            if (!entry.isPrepared || Object.values(allSlots[0].prepared).find(slot => slot.id === spellID)) return true;\n            //spell is not prepared in this entry\n            continue;\n        }\n        // remove cantrip slots from consideration from here on\n        allSlots.shift(); \n        \n        if (entry.isFocusPool) {\n            // we know we have the spell, so just test if we have focus points\n            return (actor.system.resources.focus.value >= 1);\n        }\n        // Innate spells store their uses per spell, no slots\n        if (entry.isInnate) {\n            if (extantSpell.system.location.uses.value > 0) return true;\n        }\n        \n        // if spellRank set, limit to just those slots, accounting for lack of cantrip slots\n        // otherwise limit to ranks of the spell's or higher\n        // console.warn(allSlots)\n        const relevantSlotRanks = spellRank\n                              ? [allSlots[spellRank - 1]] \n                              : allSlots.filter(sr=>sr.max > 0).slice(extantSpell.rank - 1); \n        console.warn(relevantSlotRanks);\n        if (entry.isSpontaneous) {\n            // we have already narrowed ranks down to ones that can cast the spell, do any of them have unused slots?\n            for (let slotRank of relevantSlotRanks) {\n                if (slotRank.value > 0) return true;\n            }\n        }\n        \n        if (entry.isPrepared) {\n            for (let slotRank of relevantSlotRanks) {\n                if (entry.isFlexible) {\n                    if (slotRank.value > 0) return true; // do we have any unused spell slots of sufficient rank\n                }\n                \n                preparedSlotsThisRank = Object.values(slotRank.prepared);\n                foundSpell = preparedSlotsThisRank.find(slot => slot.id === spellID && (!readyToCast || slot?.expended !== true));\n                \n                if (foundSpell) return true;\n            }\n        }\n    }\n    \n    return false;\n}\n\nconst options = {\n    // spellRank: 1,\n    // spellcastingEntry: 'Divine Flexible Spells',\n    // readyToCast: false,\n};\nlet mila = game.actors.getName('Mila');\nlet font = mila.spellcasting.contents[1] \nconsole.warn(isSpellAvailable(token.actor, 'Blur', options));",
  "folder": "MUrlWbVP9uj79bSv",
  "ownership": {
    "default": 0,
    "ZMxdSpEKesYc7gvn": 3
  },
  "flags": {
    "core": {}
  },
  "_stats": {
    "systemId": "pf2e",
    "systemVersion": "5.10.5",
    "coreVersion": "11.315",
    "createdTime": 1696824872600,
    "modifiedTime": 1702343866185,
    "lastModifiedBy": "v0RvORcwGexWLCjc"
  },
  "_id": "CimzGnBylu9AJp8W",
  "sort": 900000,
  "_key": "!macros!CimzGnBylu9AJp8W"
}
