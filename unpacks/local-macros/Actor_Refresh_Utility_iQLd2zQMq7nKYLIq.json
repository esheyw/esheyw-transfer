{
  "name": "Actor Refresh Utility",
  "type": "script",
  "scope": "global",
  "author": "v0RvORcwGexWLCjc",
  "img": "Assets/icons/material-symbols-0.4.5/sharp/sync-fill.svg",
  "command": "if (canvas.tokens.controlled.length > 1) return ui.notifications.error(\"Please select only a single token.\");\nconst token = canvas.tokens.controlled[0] ?? game.user.character?.getActiveTokens()[0];\nif (!token) return ui.notifications.error(\"Please select exactly one token or assign yourself a character.\");\n\nHandlebars.registerHelper({\n    eq: (v1, v2) => v1 === v2,\n    ne: (v1, v2) => v1 !== v2,\n    lt: (v1, v2) => v1 < v2,\n    gt: (v1, v2) => v1 > v2,\n    lte: (v1, v2) => v1 <= v2,\n    gte: (v1, v2) => v1 >= v2,\n    and() {\n        return Array.prototype.every.call(arguments, Boolean);\n    },\n    or() {\n        return Array.prototype.slice.call(arguments, 0, -1).some(Boolean);\n    }\n});\nconst style = `\n<style>\n.actor-refresh-utility img {\n  width: 3rem;\n  height: 3rem;\n}\n.actor-refresh-utility .actor-container {\n  width: 100%;\n  display: flex;\n}\n.actor-refresh-utility .actor-container span {\n  display: inline-flex;\n  align-items: center;\n  margin: auto;\n  font-size: 1.5em\n}\n.actor-refresh-utility .hidden-div {\n  display: none;\n}\n.actor-refresh-utility #force-div,\n.actor-refresh-utility #backup-div {\n  margin: 1em;\n}\n</style>\n`;\nconst labels = {\n  action: \"PF2E.ActionActionsLabel\",\n  ancestry: \"TYPES.Item.ancestry\",\n  heritage: \"TYPES.Item.heritage\",\n  background: \"TYPES.Item.background\",\n  class: \"TYPES.Item.class\",\n  feat: \"PF2E.Item.Feat.Plural\",\n  spell: \"PF2E.Item.Spell.Plural\",\n  inventory: \"PF2E.TabInventoryLabel\",\n  items: \"PF2E.Item.Plural\",\n  dance: \"Level-0-and-Back Dance\",\n  backup: \"SETUP.BACKUPS.Backup\",\n};\nconst templateData = {\n  token,\n  actor,\n  labels,\n  options: [\n    {\n      value: \"action\",\n      allowedTypes: [\"character\", \"npc\"],\n    },\n    {\n      value: \"ancestry\",\n      allowedTypes: [\"character\"],\n    },\n    {\n      value: \"heritage\",\n      allowedTypes: [\"character\"],\n    },\n    {\n      value: \"background\",\n      allowedTypes: [\"character\"],\n    },\n    {\n      value: \"class\",\n      allowedTypes: [\"character\"],\n    },\n    {\n      value: \"feat\",\n      allowedTypes: [\"character\"],\n    },\n    {\n      value: \"spell\",\n      allowedTypes: [\"character\",\"npc\"],\n    },\n    {\n      value: \"inventory\",\n      allowedTypes: [\"character\",\"npc\", \"party\"],\n    },\n    {\n      value: \"dance\",\n      allowedTypes: [\"character\"],\n      // checked: true,\n    },\n  ],\n};\nconst template = `\n<h2>Select Refresh Options {{actorType}}</h2>\n<h3>Selected Actor:</h3>\n<div class=\"actor-container\">\n  <img src=\"{{token.document.texture.src}}\" />\n  <span>{{actor.name}}</span>\n</div>\n<form>\n  <div class=\"form-group\">\n    <button type=\"button\" id=\"select-all\">Select All</button>\n    <button type=\"button\" id=\"invert\">Invert Selection</button>\n  </div>\n  <div class=\"form-group\">    \n    <fieldset id=\"refresh-options\">    \n    {{#each options as |option|}}      \n        <div class=\"flexrow{{#unless (includes option.allowedTypes ../actor.type)}} hidden-div{{/unless}}\">\n          <label for=\"{{option.value}}\">{{#with (lookup ../labels [value])}}{{localize .}}{{/with}}</label>\n          <div class=\"form-fields\">\n            <input type=\"checkbox\" name=\"{{option.value}}\" id=\"{{option.value}}\" {{checked option.checked}}/>\n          </div>\n        </div>\n    {{/each}}\n    </fieldset>\n  </div>\n  <div class=\"form-group\" id=\"force-div\">    \n    <div class=\"flexrow\">\n      <label for=\"force\">Attempt to auto-update Granters and things with ChoiceSets?</label>\n      <input type=\"checkbox\" name=\"force\" id=\"force\" />\n    </div>\n  </div>\n  <div class=\"form-group\" id=\"backup-div\">    \n    <div class=\"flexrow\">\n      <label for=\"force\">Create a backup of the selected actor before continuing?</label>\n      <input type=\"checkbox\" name=\"backup\" id=\"backup\" checked />\n    </div>\n  </div>\n</form>\n`;\nfunction aruRenderCallback(html) {\n  const checkboxes = html.querySelectorAll('#refresh-options input[type=checkbox]');\n  \n  const selectAll = html.querySelector('#select-all');\n  selectAll.addEventListener('click', () => {\n    for (const box of checkboxes) box.checked = true;\n  });\n  const invert = html.querySelector('#invert');\n  invert.addEventListener('click', () => {\n    for (const box of checkboxes) box.checked = !box.checked;\n  });\n}\nconst body = Handlebars.compile(template)(templateData);\nconst dialogData = {\n  title: `Actor Refresh Utility`,\n  content: style + body,\n  close: () => false,\n  buttons: {\n    refresh: {\n      label: `Refresh`,\n      icon: `<i class=\"fa-solid fa-arrows-rotate\"></i>`,\n      callback: (html) => new FormDataExtended(html.querySelector(\"form\")).object,\n    },\n    cancel: {\n      label: `Cancel`,\n      icon: `<i class=\"fa-solid fa-times\"></i>`,\n      callback: () => false,\n    },\n  },\n  default: `refresh`,\n  render: aruRenderCallback,\n};\nconst dialogOptions = {\n  width: 350,\n  jQuery: false,\n  classes: [\"actor-refresh-utility\"],\n};\nconst response = await Dialog.wait(dialogData, dialogOptions);\nif (!response) return;\n\nconst unrefreshed = {};\nconst refreshed = {};\nconst actionables = Object.entries(response).filter(([type,selected]) => selected && !['force','backup'].includes(type)).map(([t,s]) => t);\nif (response.backup) {\n  const actorData = actor.toObject();\n  actorData.name = `BACKUP ${actorData.name}`;\n  await Actor.create(actorData);\n}\nfor (const type of actionables) {\n  if (type === 'dance') {\n    const currentLevel = actor.level;\n    await actor.update({\"system.details.level.value\": 0});\n    await actor.update({\"system.details.level.value\": currentLevel});\n    continue;\n  }\n  const types = type === 'inventory' ? ['armor','backpack','book','consumable','equipment','shield','treasure','weapon'] : [type];\n  const items = [];\n  for (const t of types) items.push(...actor.itemTypes[t]);\n  \n  unrefreshed[type] ??= [];\n  refreshed[type] ??= [];\n  for (const item of items) {    \n    const grantedBy = item?.flags?.pf2e?.grantedBy;\n    if (grantedBy) {\n      //don't mark unrefreshed if the dance would refresh it\n      const granter = actor.items.get(grantedBy.id);\n      if (granter?.category === 'classFeature') continue; \n      unrefreshed[type].push({        \n        item,\n        reason: `Granted by \"${granter?.name ?? '<em>Granter Not Found</em>'}\".`\n      });\n      continue;\n    }\n    const sourceID = item?.flags?.core?.sourceId;\n    if (!sourceID) {\n      unrefreshed[type].push({\n        item,\n        reason: `Item does not have a listed compendium Source.`\n      });\n      continue;\n    }\n    const newSource = await fromUuid(sourceID);\n    if (!newSource) {\n      unrefreshed[type].push({\n        item,\n        reason: `Item's compendium source not found (probably not reprinted).`\n      })\n      continue;\n    }\n    const newSourceData = newSource.toObject();\n    const existingBlockingRules = (item.system?.rules ?? []).filter(r=>['GrantItem','ChoiceSet'].includes(r.key));\n    const newBlockingRules = (newSource.system?.rules ?? []).filter(r=>['GrantItem','ChoiceSet'].includes(r.key));\n    if (existingBlockingRules.length || newBlockingRules.length) {\n      if (!response.force) {\n        let reason = existingBlockingRules.length ? \n                      `Item` :\n                      `Item's compendium source`;\n        reason += ` contains rules preventing it from being refreshed simply.`;          \n        unrefreshed[type].push({item, reason});\n        continue;\n      }\n      \n      const [existingGrants,existingChoices] = existingBlockingRules.partition(r => r.key === 'ChoiceSet');\n      const [newGrants,newChoices] = newBlockingRules.partition(r => r.key === 'ChoiceSet');      \n      const grantsMatch = !!Object.keys(diffObject(newGrants,existingGrants)).length;\n      \n      let choicesMatch = true;\n      if (existingChoices.length === newChoices.length) {\n        for (let i = 0; i < existingChoices.length; i++) {\n          console.warn('choice!', {name:item.name, nc: newChoices[i], ec: existingChoices[i]});\n          choicesMatch = !!Object.keys(diffObject(newChoices[i].choices,existingChoices[i].choices)).length\n        }\n      } else {\n        // choicesMatch \n      }     \n    } else {\n      try {\n        await item.refreshFromCompendium();\n      } catch(error) {\n        unrefreshed[type].push({\n          item,\n          reason: error.toString()\n        });\n        continue;\n      }       \n    }\n    refreshed[type].push(item);\n  }\n}\n\nconst unrefreshedTemplateData = {\n  labels,\n  itemgroups: Object.entries(unrefreshed).map(([group,items]) => ({label:group, items})),\n};\nconst unrefreshedCount = unrefreshedTemplateData.itemgroups.reduce((acc,curr) => acc += curr.items.length, 0);\nlet unrefreshedTemplate;\nif (!unrefreshedCount) {\n  unrefreshedTemplate = `\n<h2>All Selected Items Refreshed!</h2>  \n${actor.name}'s items of the selected types are now up to date to the best of this tool's ability.\n`;\n} else {\n  unrefreshedTemplate = `\n<h2>Unrefreshed Items</h2>\n<table>\n  {{#each itemgroups as |group|}}\n  {{#if (gt items.length 0)}}\n    <tr>\n      <th colspan=\"2\">{{#with (lookup ../labels [label])}}{{localize .}}{{/with}}</th>\n    </tr>\n    {{#each items as |item|}}\n    <tr>\n      <td>@UUID[{{item.uuid}}]</td>\n      <td>{{item.reason}}</td>\n    </tr>\n    {{/each}}\n  {{/if}}  \n  {{/each}}\n</table>\n`;\n}\n// return console.warn((Handlebars.compile(unrefreshedTemplate))(unrefreshedTemplateData))\nDialog.prompt({\n  title: `ARU Summary`,\n  content: await TextEditor.enrichHTML((Handlebars.compile(unrefreshedTemplate))(unrefreshedTemplateData)),\n  options: {\n    jQuery: false,\n    width: unrefreshedCount ? 600 : 400,\n  }\n});\nconsole.warn(refreshed)",
  "folder": "MUrlWbVP9uj79bSv",
  "flags": {
    "core": {}
  },
  "_stats": {
    "systemId": "pf2e",
    "systemVersion": "5.10.5",
    "coreVersion": "11.315",
    "createdTime": 1702154899551,
    "modifiedTime": 1702343866245,
    "lastModifiedBy": "v0RvORcwGexWLCjc"
  },
  "_id": "iQLd2zQMq7nKYLIq",
  "sort": 0,
  "ownership": {
    "default": 0,
    "v0RvORcwGexWLCjc": 3
  },
  "_key": "!macros!iQLd2zQMq7nKYLIq"
}
