{
  "name": "delete actor and all tokens",
  "type": "script",
  "scope": "global",
  "author": "v0RvORcwGexWLCjc",
  "img": "Assets/icons/game-icons-net/blackbackground/skeleton.svg",
  "command": "//Check for exactly one selected token\nif (canvas.tokens.controlled.length > 1) {\n    ui.notifications.warn(\"Please select only a single or zero token(s).\");\n    return;\n}\nfunction localize(key) {\n     return game.i18n.localize(key);\n}\nclass ValidatedDialog extends Dialog {\n    submit(button, event) {\n        if (button.label === 'Submit') {\n            if (!this.element[0].querySelector('#actorID').value\n             && !this.element[0].querySelector('#groupType').value) {                 \n                return ui.notifications.warn('Please select something to delete!');\n            }\n        }\n        super.submit(button, event);\n    }\n}\n\nlet toBeKilled = game.actors.get(canvas.tokens.controlled[0]?.actor.id);\n\nlet response = '';\nif (!toBeKilled) {\n    function generateOptions(filter = (f) => true) {\n        let out = ``;\n        const folders = game.folders.filter(f => f.type === 'Actor')\n        if (folders.length) {\n            out += `<optgroup label=\"Folders\">`;\n            for (const f of folders) {\n                out += `<option value=\"${f.id}\">${f.name}</option>`;\n            }\n            out += `</optgroup>`;\n        }\n    \n        out += `<optgroup label=\"Other Groupings\">`;\n        for (const [type,label] of Object.entries(CONFIG.Actor.typeLabels)) {\n            out += `<option value=\"${type}\">Type: ${localize(label)}</option>`   \n        }    \n        out += `</optgroup>`\n        return out;\n    }\n    function generateActors(filter = (f) => true) {\n        let out = '';\n        for (const [type,label] of Object.entries(CONFIG.Actor.typeLabels)) {\n            const actors = game.actors.filter(a => a.type === type).filter(filter);\n            if (actors.length) {\n                out += `<optgroup label=\"${localize(label)}\">`;\n                for (const actor of actors) {\n                    out += `<option value=\"${actor.uuid}\">${actor.name}</option>`;\n                }\n                out += `</optgroup>`;\n            }\n        }\n        return out;\n    }\n    const form = `\n    <form>\n        <div class=\"form-group\">\n            <label for=\"actorID\">Select Actor:&nbsp;</label>\n            <select id=\"actorID\" name=\"actorID\">\n                <option id=\"defaultoption\" value=\"\" selected></option>\n                ${generateActors()}\n            </select>\n        </div>\n        <div class=\"form-group\">\n            <label for=\"groupType\">Or Select Grouping:&nbsp;</label>\n            <select id=\"groupType\" name=\"groupType\">\n                <option id=\"defaultoption\" value=\"\" selected></option>\n                ${generateOptions()}\n            </select>\n        </div>\n        <div class=\"form-group\">\n            <label for=\"fdelete\">Delete Folder:&nbsp;</label>\n            <input type=\"checkbox\" name=\"fdelete\" id=\"fdelete\" />\n        </div>                  \n    </form> \n    `;\n  \n    function renderCallback(html) {\n        html[0].closest('.app').addEventListener('drop', dropCallback);\n    }\n    async function dropCallback(event) {\n        const dropdata = JSON.parse(event.dataTransfer?.getData(\"text/plain\"));\n        if (!dropdata || dropdata.type !== 'Actor') {\n            ui.notifications.warn('Not an Actor');\n            return;      \n        } \n        actor = await fromUuid(dropdata.uuid);\n        if (!actor) return ui.notifications.warn(`Couldn't retrieve effect ${dropdata.uuid}`);\n        this.querySelector('#actorID').value = actor.uuid;\n    }\n    function pickTarget(html) {    \n        const formElement = html[0].querySelector('form');\n        const formData = new FormDataExtended(formElement);\n        return formData.toObject();\n    }\n    const dData = {\n        title: \"Select Actor to Remove\",\n        content: form,\n        render: renderCallback,\n        buttons: {      \n            submit: { label: \"Submit\", callback: pickTarget, icon: '<i class=\"fas fa-check\"></i>' },            \n            cancel: { label: \"Cancel\", icon: '<i class=\"fas fa-times\"></i>' }\n        },\n        default: 'submit',\n    } \n    const dOpts = {\n        height: \"auto\",\n        width: \"auto\",\n    }\n    response = await ValidatedDialog.wait(dData, dOpts);\n    if (response === 'cancel') return;\n    toBeKilled = await fromUuid(response.actorID);\n}\nif (toBeKilled) {\n    const cData = {\n      title: `Deleting ${toBeKilled.name}`,\n      content: `Are you sure you want to delete <strong>${toBeKilled.name}</strong> <em>and</em> all their associated tokens from this world?`,\n      yes: () => {},\n      no: () => {},\n      defaultYes: false\n    }\n    const confirm = await Dialog.confirm(cData);\n    if (confirm !== 'yes') return;\n    for (const scene of game.scenes) {\n        for (const token of scene.tokens) {\n            if (token.actorId === toBeKilled.id) {\n                token.delete();\n            }\n        }\n    }\n    toBeKilled.delete();\n}\nif (response.groupType) {\nlet cData = '';\nlet killfolder = '';\n    \n    let actors = [];\n    if (Object.keys(CONFIG.Actor.typeLabels).includes(response.groupType)) {\n        cData = {\n          title: `Deleting All ${localize(CONFIG.Actor.typeLabels[response.groupType])}`,\n          content: `Are you sure you want to delete <strong>All ${localize(CONFIG.Actor.typeLabels[response.groupType])}</strong> actors <em>and</em> all their associated tokens from this world?`,\n          yes: () => {},\n          no: () => {},\n          defaultYes: false\n        }\n        actors = game.actors.filter(a => a.type === response.groupType)\n    } else {\n        killfolder = game.folders.find(f => f.id === response.groupType);\n        cData = {\n          title: `Deleting Contents of Folder ${killfolder.name}`,\n          content: `Are you sure you want to delete <strong>All</strong> actors in <strong>${killfolder.name}</strong> <em>and</em> all their associated tokens from this world`,\n          yes: () => {},\n          no: () => {},\n          defaultYes: false\n        }\n        if (response.fdelete) cData.content += `, as well as the folder`;\n        cData.content += `?`;\n        actors = killfolder.contents;\n    }\n    \n    const confirm = await Dialog.confirm(cData);\n    if (confirm !== 'yes') return;\n    \n    for (const a of actors) {\n        for (const scene of game.scenes) {\n            for (const token of scene.tokens) {\n                if (token.actorId === a.id) {\n                    token.delete();\n                }\n            }\n        }\n        a.delete();\n    }\n    if (response.fdelete && killfolder) killfolder.delete();\n}",
  "flags": {
    "advanced-macros": {
      "runAsGM": true,
      "runForSpecificUser": ""
    },
    "cf": null,
    "core": {}
  },
  "_stats": {
    "systemId": "pf2e",
    "systemVersion": "5.10.5",
    "coreVersion": "11.315",
    "createdTime": 1681184212163,
    "modifiedTime": 1702343866185,
    "lastModifiedBy": "v0RvORcwGexWLCjc"
  },
  "_id": "3Os0Z9Aiw84ZIsar",
  "folder": "MUrlWbVP9uj79bSv",
  "sort": 1100000,
  "ownership": {
    "default": 0,
    "holNdNHqtCzAbMAV": 3,
    "717Xeq3czH96acPF": 3,
    "ZMxdSpEKesYc7gvn": 3
  },
  "_key": "!macros!3Os0Z9Aiw84ZIsar"
}
