{
  "name": "backupParty",
  "type": "script",
  "scope": "global",
  "author": "v0RvORcwGexWLCjc",
  "img": "icons/svg/dice-target.svg",
  "command": "async function backupParty({\n  party = null,\n  pack = null,\n  keepId = true,\n  overwrite = false,\n  unlock = false,\n  backupCount = 3,\n} = {}) {\n  const FUNC = \"backupParty\";\n  let packID = (providedPack = \"\");\n  const now = new Date();\n  //party can be an actor ID, a party name, or a party document reference\n  if (typeof party === \"string\") {\n    const providedParty = party;\n    party = fromUuidSync(party) ?? game.actors.get(party) ?? game.actors.getName(party);\n    if (!party) {\n      return !ui.notifications.error(\n        `${FUNC}: provided party \"${providedParty}\" not a valid ID or name in this world.`\n      );\n    }\n  }\n  if (!(party instanceof Actor) || party.type !== \"party\") {\n    console.error(`${FUNC}: Provided party variable: `, providedParty);\n    return !ui.notifications.error(\n      `${FUNC}: provided party reference resolved to \"${party?.name}\" (${party.uuid}), not a party.`\n    );\n  }\n  //pack can, similar to party, be a pack ID, pack name, or CompendiumCollection.\n  if (typeof pack === \"string\") {\n    providedPack = pack;\n    pack = game.packs.get(providedPack);\n    pack ??= game.packs.find((p) => p.metadata.label === providedPack);\n\n    if (!pack) return !ui.notifications.error(`${FUNC}: provided pack \"${providedPack}\" not found.`);\n\n    packID = pack.collection;\n  } else if (pack instanceof CompendiumCollection) {\n    if (pack.documentName !== \"Actor\")\n      return !ui.notifications.error(\n        `${FUNC}: Provided pack \"${pack.metadata.label}\" (${pack.collection}) is not an Actor compendium (${pack.documentName})`\n      );\n    packID = pack.collection;\n  } else {\n    //only bother logging pack if provided\n    if (pack !== null) console.error(`${FUNC}: Provided pack variable: `, pack);\n    return !ui.notification.error(`${FUNC}: no valid target pack provided for backup.`);\n  }\n\n  if (pack.documentName !== \"Actor\")\n    return !ui.notifications.error(\n      `${FUNC}: provided pack \"${pack.metadata.label}\" (${packID}) is not an Actor compendium`\n    );\n\n  if (pack.locked) {\n    if (unlock) {\n      await pack.configure({ locked: false });\n    } else {\n      return !ui.notifications.error(`${FUNC}: provided pack \"${pack.metadata.label}\" (${packID}) is locked.`);\n    }\n  }\n  const displayTime = (date) => date.toISOString().slice(0, 16).replace(\"T\", \" \") + \" UTC\";\n  const folders = pack.folders;\n  let existingBackupFolders = folders\n    .filter((f) => f.flags?.world?.backupPartyID === party.id)\n    .sort((a, b) => a.flags.world.partyBackupTime - b.flags.world.partyBackupTime);\n\n  if (existingBackupFolders.length > backupCount) {\n    const difference = existingBackupFolders.length - backupCount;\n    const lastAllowed = existingBackupFolders.at(-(difference + 1));\n    const lastAllowedSavedTime = lastAllowed.flags.world.backupPartyTime;\n    const toDiscardIDs = existingBackupFolders.slice(-difference).map((f) => f.id);\n    const content = `<h2>Too Many Backups</h2>More backups found than specificied allowed backup count (${backupCount}).<br />\nDelete oldest ${difference} backup(s), leaving the most recent as being from ${displayTime(\n      new Date(lastAllowedSavedTime)\n    )}?`;\n    const overageResponse = await Dialog.confirm({\n      title: `Delete Backups Beyond Specified Count?`,\n      content,\n    });\n    if (!overageResponse)\n      return !ui.notifications.info(\"Backup aborted (chose not to delete backups beyond specified count limit).\");\n\n    await Folder.deleteDocuments(toDiscardIDs, {\n      deleteSubfolders: true,\n      deleteContents: true,\n      pack: packID,\n    });\n    //update our folder list after deletions\n    existingBackupFolders = existingBackupFolders.filter((f) => !toDiscardIDs.includes(f.id));\n  }\n  \n  if (existingBackupFolders.length === backupCount) {\n    const lastFolder = existingBackupFolders.at(-1);\n    const lastSavedTime = lastFolder.flags.world.backupPartyTime;\n    if (!overwrite) {\n      const deleteResponse = await Dialog.confirm({\n        title: `Delete Oldest Backup?`,\n        content: `<h2>Backup count (${backupCount}) reached. </h2>\n                  Delete oldest backup for: <br /> \n                  <strong>${party.name}</strong> (saved ${displayTime(new Date(lastSavedTime))})?`,\n      });\n      if (!deleteResponse)\n        return !ui.notifications.info(\"Backup aborted (backup count reached, chose not to delete oldest).\");\n    }\n    // if overwrite = true, or we got permission, delete the oldest backup\n    await lastFolder.delete({ deleteSubfolders: true, deleteContents: true });\n  }\n\n  const firstSort = existingBackupFolders[0]?.sort ?? -CONST.SORT_INTEGER_DENSITY;\n  const newFolder = await Folder.create(\n    {\n      name: `Backup: ${party.name} (${displayTime(now)})`,\n      type: \"Actor\",\n      flags: {\n        world: {\n          backupPartyName: party.name,\n          backupPartyID: party.id,\n          backupPartyTime: now.getTime(),\n        },\n      },\n      sort: firstSort - CONST.SORT_INTEGER_DENSITY,\n    },\n    { pack: packID }\n  );\n\n  //if we just do {members} = party we get reference weirdness\n  const members = party.system.details.members.map((m) => fromUuidSync(m.uuid));\n  members.push(party);\n\n  const creations = members.map((m) => {\n    const data = m.toObject();\n    if (typeof data.flags !== \"object\") data.flags = {};\n    data.flags.world ??= {};\n    data.flags.world.backupPartyOriginalID = m.id;\n    data.folder = newFolder.id;\n    return data;\n  });\n\n  const createOptions = {\n    pack: packID,\n    keepId: backupCount === 1 && keepId, // only save with original IDs if we're not going to get conflicts\n  };\n  const created = await Actor.createDocuments(creations, createOptions);\n\n  if (pack.sortingMode === \"a\") pack.toggleSortingMode();\n  await pack.render(true);\n\n  return {\n    folder: newFolder,\n    created,\n  };\n}\n\nconst out = await backupParty({\n  pack: \"esheyw-transfer.local-pf2e-actors2\",\n  party: \"xxxPF2ExPARTYxxx\",\n  unlock: true,\n  backupCount: 2,\n});\nconsole.warn({ out });",
  "folder": "S2KSaNQJxdlRFkyr",
  "ownership": {
    "default": 0,
    "xuYHxk9sJoYKM7d6": 3
  },
  "flags": {
    "world": {
      "testingCounter": 58
    },
    "core": {}
  },
  "_stats": {
    "systemId": "pf2e",
    "systemVersion": "5.10.5",
    "coreVersion": "11.315",
    "createdTime": 1701630541560,
    "modifiedTime": 1702343866185,
    "lastModifiedBy": "v0RvORcwGexWLCjc"
  },
  "_id": "LDWtZKWOypbbNPVK",
  "sort": 400000,
  "_key": "!macros!LDWtZKWOypbbNPVK"
}
